# SQL-GOD-LEVEL

Types of databases mainly classified 

1\. SQL

a. Structured data

b. data should be secure.

c. Transaction control is needed.

example : oracle, mysql,sql server, postgrSQL



2\. NoSQL

a. unstructured

b. data should be secure.

c. No transaction control

examples: mongodb, CouchbaseDB, Cassendra

---------------------------------------------------------------------------------------------------

Type of statements 

DQL(Data query language) = select

DCL(Data control language) = grant revoke

TCL(Transaction Control language) = commit,rollback,savepoint

DDL(Data Definition language) = create,alter,truncate drop 

DML(Data Manipulation language) =insert , update, delete

---------------------------------------------------------------------------------------------------

ACID Properties 


Automicity = here either all operation will excute or nothing will get excute 

entire transaction is excueted as single unit



Consistency = after every transaction data will be at correct state



isolation = the intermediate changes are not visible to users is called isolation



durability = the correctness after every transaction will stay for longer duration

------------------------------------------------------------------------------------------------

Basic operators

1. And = combine two conditions 
2. or = one or else condition
3. in = choose between multiple values 
4. between = choose between certain range

------------------------------------------------------------------------------------------------

flow of query 

select from
join 
where 
group by
having 
order by
limit offset
---------------------------------------------------------------------------------------------------
like 
















---------------------------------------------------------------------------------------------------
Regexp 




























---------------------------------------------------------------------------------------------------
Distinct keyword = gives unique values according from the table 

limit clause = assings limit 
ex = to display first 2 rows
select * from emp
limit 2;

of use offset(skip) the entries
following query will skip 2 rows and display 3 rows
select * from emp
limit 2,3;


---------------------------------------------------------------------------------------------------
Agreegate fucntions 
1.sum
2.min
3.max
4.avg

---------------------------------------------------------------------------------------------------
single row functions
1. number functions ( 7 total )

1.abs(num) it will convert -ve value to +ve val
2.sqrt(num) to find sqrt of the number
3.ceil(num) It will always give the next minimum number
EX = ceil(3.12)=4
     ceil(3.65)=4

4.floor(num) It will always give the previous maximum number
EX = floor(3.12)=3
     floor(3.76)=3

5.round(num,precesion) it will round the value upto precision

EX = round(1.4567,2)=1.46
     round(1.4512,2)=1.45

6.truncate(num,precision) It will truncate the         value upto precision

EX = truncate(1.4567,2)=1.45
     truncate(1.4512,2)=1.45

7.pow(num,raiseto) will find num raiseto
 EX = pow(3,2)=9

---------------------------------------------------------------------------------------------------

string Functions

1.upper(val) convert string into uppercase
2.lower(val) convert string into lowercase
3.concat(str1,str2,str3,......) it combine all 
the strings to form single string

4.substr(str,start,length) will retrieve portion of the string starting from start value, length
number of characters

5.left(str,length) will retrieve length number of leftmost characters

6.right(str,length) will retrieve length number of rightmost characters

7.trim(str) it will remove all leading and trailing spaces

8.rtrim(str) it will remove all trailing spaces

9.ltrim(str) it will remove all leading spaces

10.instr(str,substr) it will return the position of first occurrence of substr in the given
string

11.replace (str,oldstr,newstr) It will replace all occurrence of oldstr with newstr in the givenstring

12.format(value,precision) It displays thousand separators in the number
300,000,000.00

13.lpad(str,length,character) add given character on left of the sting, so that the total length will be length
EX = select empno,ename,concat(ename,"-----
",job),concat(rpad(ename,12,'-'),job)
 from emp;

14.rpad(str,length,character) add given character on right of the sting, so that the total length will be lenghth

15.length(str) number of characters in the given string

---------------------------------------------------------------------------------------------------
date fucntions 

1.now() it will display current date and time
curdate() it will display current date

2.date_format(date,format) to display the date in specified format
Y --- will display 4 digit year
y----will display 2 digit year
M- month name in character
m-month in number
d- date in number
D- display th or st after date
b--- display months in 3 letter (jan, feb,....)
r ---- to print time in 12 hrs (hh:mm:ss AM/PM)
%W---- Weekday name (Sunday..Saturday)
%w--- Day of the week (0=Sunday..6=Saturday)

2.date_add(date,interval) it will find the date after given interval 
# uses between intervals only
EX = date_add(curdate(),interval 2 day)
     date_add(curdate(),interval 2 month)
     date_add(curdate(),interval 2 year)

3.date_sub(date,interval) it will find the date after given interval
# uses only for intervals only
EX = date_sub(curdate(),interval 2 day)
     date_sub(curdate(),interval 2 month)
     date_sub(curdate(),interval 2 year)

4.datediff(date1,date2) find the difference between 2 dates

5.timestampdiff(YEAR, date1,
CURDATE())
find difference between 2 dates in terms of years
EX = SELECT TIMESTAMPDIFF (YEAR, YOUR_COLUMN, CURDATE()) FROM
YOUR_TABLE AS AGE

6.Extraction of day month and year and week from date 

day(date)
month(date)
year(date)
week(date)
quarter(date)

NOTE = day or month or year or week or quarter of the given date then use
these functions

7.extract(date, fmt) to find day month or year from date
EX = extract(month from curdate())
     extract(year from curdate())
     extract(day from curdate())

8.mothname(date) it will find name of month in character
9.dayname(date) it will display dayname of the given date
10.last_day(date) it will display last day of the current month

---------------------------------------------------------------------------------------------------
CASE ( if else syntax)
EX = if comm is null or 0 then poor performance
if comm <=300 then ‘ok performance’
if >300 and <=500 then ‘good performance’
otherwise excellent performance

Ans = select empno,ename,sal,comm,case 
      when comm is null or comm=0 then'poor performance'
      when comm<=300 then 'ok performance'
      when comm<=500 then 'good performance'
      else 'excellent performance' end comment
      from emp;
---------------------------------------------------------------------------------------------------

types of keys

1.primary key minimal set of columns which identifies the row uniquely is called as
primary key
There will be only one primary key
if primary key contains single column then it is called as primary key
if primary contains more than one column, then it is called as
composite primary key

2.candidate key all possible minimal set of columns which identifies the row uniquely
is called as candidate key

3.surrogate key if primary key has multiple columns and if managing the data is
difficult, then we add one extra column to make the row unique, is
called as surrogate key

4.alternate key all candidate keys which are not chosen as primary key is are called as

5.alternate key
super key any combination of columns which identifies the row uniquely is
called as super key

6.foreign key it is a column which refers column of primary key or unique column of
other table or of same table, then it is called as foreign
In a table there can be more than one foreign key


auto_increment
will generate unique values automatically, it can be used only with int
columns, and on primary key which has only 
single column.

---------------------------------------------------------------------------------------------------

1.primary key 
minimal set of columns which identifies the row uniquely is called as primary key
There will be only one primary key
if primary key contains single column then it is called as primary key
if primary contains more than one column, then it is called as
composite primary key

2.candidate key all possible minimal set of columns which identifies the row uniquely
is called as candidate key

3.surrogate key if primary key has multiple columns and if managing the data is
difficult, then we add one extra column to make the row unique, is called as surrogate key

4.alternate key all candidate keys which are not chosen as primary key is are called as alternate key

5.super key any combination of columns which identifies the row uniquely iscalled as super key

6.foreign key it is a column which refers column of primary key or unique column of
other table or of same table, then it is called as foreign
In a table there can be more than one foreign key

---------------------------------------------------------------------------------------------
DML 
1.insert record 
# if you know the schema
insert into <table name> values(<list of values>)

# if you dont know schema
insert into <table name>(<list of columns>) values(<list of values>)

2.delete record 
# note in while condition if we didn't specified a condition then it will delete all records 

delete from <table name>
where <condition>

3.update
# note in while condition if we didn't specified a condition then it will update all records 

update <table name>
set col1=val1,col2=val2,col3=val3
where <condition>

Truncate vs delete
truncate table mytable;
it will delete all records but will not delete the table, so empty table will remain

delete vs drop vs truncate 

delete = 1.delete specific rows as specified
         2.can use where to specify condition
         3.rollback possible
drop 1.drop entire with enteries and whole schema nothing remains

truncate = 1.delete all entries
           2.schema remains without any entry
           3. no where clause is used

----------------------------------------------------------------------------------------------
alter table 













----------------------------------------------------------------------------------------------
nested query














----------------------------------------------------------------------------------------------
joins
sample tables to understand joins 

employee table

+--------+----------+--------+---------+------------+
| emp_id | emp_name | salary | dept_id | manager_id |
+--------+----------+--------+---------+------------+
| E1     | Rahul    |  10000 | D1      | M1         |
| E2     | Manoj    |  15000 | D1      | M1         |
| E3     | James    |  55000 | D2      | M2         |
| E4     | Michael  |  25000 | D2      | M2         |
| E5     | All      |  20000 | D10     | M3         |
| E6     | Robin    |  35000 | D10     | M3         |
+--------+----------+--------+---------+------------+ 


department table
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
| D1      | IT        |
| D2      | HR        |
| D3      | Fianance  |
| D4      | Admin     |
+---------+-----------+


manager table
+------------+--------------+---------+
| manager_id | manager_name | dept_id |
+------------+--------------+---------+
| M1         | Prem         | D3      |
| M2         | Shripadh     | D4      |
| M3         | Nick         | D1      |
| M4         | Cory         | D1      |
+------------+--------------+---------+

project table
+------------+----------------+----------------+
| project_id | project_name   | team_member_id |
+------------+----------------+----------------+
| P1         | Data Migration | E1             |
| P2         | Data Migration | E2             |
| P1         | Data Migration | M3             |
| P2         | ETL            | E1             |
| P2         | ETL            | M4             |
+------------+----------------+----------------+


1.inner join or join
only displays matching reocords nothing else is displayed 

mysql> select e.emp_name,d.dept_name from employee e  join department d
    -> on e.dept_id = d.dept_id ;
+----------+-----------+
| emp_name | dept_name |
+----------+-----------+
| Rahul    | IT        |
| Manoj    | IT        |
| James    | HR        |
| Michael  | HR        |
+----------+-----------+
4 rows in set (0.00 sec)

2. left join 

in left join = inner join + any additional records from left table

mysql> -- left join
mysql> select e.emp_name,d.dept_name from employee e  left join department d
    -> on e.dept_id = d.dept_id ;
+----------+-----------+
| emp_name | dept_name |
+----------+-----------+
| Rahul    | IT        |
| Manoj    | IT        |
| James    | HR        |
| Michael  | HR        |
| All      | NULL      |
| Robin    | NULL      |
+----------+-----------+
 
-- left join on multiple tables

display all emp names and deptname and manager table and project name join all tables

mysql> select e.emp_name , d.dept_name , m.manager_name , p.project_name
    -> from employee e left join department d on e.dept_id = d.dept_id
    -> join manager m on m.manager_id = e.manager_id
    -> left join project p on p.team_member_id = m.manager_id;
+----------+-----------+--------------+----------------+
| emp_name | dept_name | manager_name | project_name   |
+----------+-----------+--------------+----------------+
| Rahul    | IT        | Prem         | NULL           |
| Manoj    | IT        | Prem         | NULL           |
| James    | HR        | Shripadh     | NULL           |
| Michael  | HR        | Shripadh     | NULL           |
| All      | NULL      | Nick         | Data Migration |
| Robin    | NULL      | Nick         | Data Migration |
+----------+-----------+--------------+----------------+

note = before last query  all part is considered as left join because to display all records therefore it needs left join 

3. full outer join / full join( not supported in my sql)

full join = inner join + left join + right join 
 select e.emp_name , d.dept_name from employee e
     full join department d on e.dept_id = d.dept_id;

my sql syntax

 select e.emp_name , d.dept_name from employee e
    -> left join department d on e.dept_id = d.dept_id
    -> union
    -> select e.emp_name , d.dept_name from employee e
    -> right join department d on e.dept_id = d.dept_id;
+----------+-----------+
| emp_name | dept_name |
+----------+-----------+
| Rahul    | IT        |
| Manoj    | IT        |
| James    | HR        |
| Michael  | HR        |
| All      | NULL      |
| Robin    | NULL      |
| NULL     | Fianance  |
| NULL     | Admin     |
+----------+-----------+

required union here

4. cross join (cartesian join )
makes all possible combinations from joins doesnt require join condition or any matching column condtion

select e.emp_name , d.dept_name , c.company_name , c.location
    -> from employee e
    -> inner join department d on e.dept_id = d.dept_id
    -> cross join company c;
+----------+-----------+--------------+----------+
| emp_name | dept_name | company_name | location |
+----------+-----------+--------------+----------+
| Rahul    | IT        | Devansh      | bhandara |
| Manoj    | IT        | Devansh      | bhandara |
| James    | HR        | Devansh      | bhandara |
| Michael  | HR        | Devansh      | bhandara |
+----------+-----------+--------------+----------+


5. self join


mysql> select * from family;
+-----------+---------+-----------+------+
| family_id | name    | parent_id | age  |
+-----------+---------+-----------+------+
| F1        | David   | F5        | NULL |
| F2        | Carol   | F5        | NULL |
| F3        | Michael | F5        | NULL |
| F4        | Johnson |           | NULL |
| F5        | Mayhem  | F6        | NULL |
| F6        | Stewart |           | NULL |
| F7        | Rohan   | F4        | NULL |
| F8        | Asha    | F4        | NULL |
+-----------+---------+-----------+------+


select child.name as "cnanme" , child.age as "childage"
    -> parent.name as "parent_name" ^C
mysql> select child.name as "cnanme" , child.age as "childage",
    -> parent.name as "parent_name",
    -> parent.age as "parent_age"
    -> from family as child
    -> join family as parent on child.parent_id = parent.parent_id;
+---------+----------+-------------+------------+
| cnanme  | childage | parent_name | parent_age |
+---------+----------+-------------+------------+
| Michael |       50 | David       |         45 |
| Carol   |       38 | David       |         45 |
| David   |       45 | David       |         45 |
| Michael |       50 | Carol       |         38 |
| Carol   |       38 | Carol       |         38 |
| David   |       45 | Carol       |         38 |
| Michael |       50 | Michael     |         50 |
| Carol   |       38 | Michael     |         50 |
| David   |       45 | Michael     |         50 |
| Stewart |       75 | Johnson     |         60 |
| Johnson |       60 | Johnson     |         60 |
| Mayhem  |       70 | Mayhem      |         70 |
| Stewart |       75 | Stewart     |         75 |
| Johnson |       60 | Stewart     |         75 |
| Asha    |       18 | Rohan       |         20 |
| Rohan   |       20 | Rohan       |         20 |
| Asha    |       18 | Asha        |         18 |
| Rohan   |       20 | Asha        |         18 |
+---------+----------+-------------+------------+

